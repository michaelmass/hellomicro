// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: proto/service.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Hellomicro_Ping_FullMethodName         = "/api.hellomicro.v1.Hellomicro/Ping"
	Hellomicro_Crash_FullMethodName        = "/api.hellomicro.v1.Hellomicro/Crash"
	Hellomicro_Panic_FullMethodName        = "/api.hellomicro.v1.Hellomicro/Panic"
	Hellomicro_Exit_FullMethodName         = "/api.hellomicro.v1.Hellomicro/Exit"
	Hellomicro_Log_FullMethodName          = "/api.hellomicro.v1.Hellomicro/Log"
	Hellomicro_Latency_FullMethodName      = "/api.hellomicro.v1.Hellomicro/Latency"
	Hellomicro_Info_FullMethodName         = "/api.hellomicro.v1.Hellomicro/Info"
	Hellomicro_Environments_FullMethodName = "/api.hellomicro.v1.Hellomicro/Environments"
	Hellomicro_Echo_FullMethodName         = "/api.hellomicro.v1.Hellomicro/Echo"
	Hellomicro_Request_FullMethodName      = "/api.hellomicro.v1.Hellomicro/Request"
	Hellomicro_ListFiles_FullMethodName    = "/api.hellomicro.v1.Hellomicro/ListFiles"
	Hellomicro_ReadFile_FullMethodName     = "/api.hellomicro.v1.Hellomicro/ReadFile"
	Hellomicro_WriteFile_FullMethodName    = "/api.hellomicro.v1.Hellomicro/WriteFile"
	Hellomicro_DeleteFile_FullMethodName   = "/api.hellomicro.v1.Hellomicro/DeleteFile"
)

// HellomicroClient is the client API for Hellomicro service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HellomicroClient interface {
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Crash(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Panic(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Exit(ctx context.Context, in *ExitReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Log(ctx context.Context, in *LogReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Latency(ctx context.Context, in *LatencyReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*InfoRes, error)
	Environments(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*EnvironmentsRes, error)
	Echo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*EchoRes, error)
	Request(ctx context.Context, in *RequestReq, opts ...grpc.CallOption) (*RequestRes, error)
	ListFiles(ctx context.Context, in *ListFilesReq, opts ...grpc.CallOption) (*ListFilesRes, error)
	ReadFile(ctx context.Context, in *ReadFileReq, opts ...grpc.CallOption) (*ReadFileRes, error)
	WriteFile(ctx context.Context, in *WriteFileReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteFile(ctx context.Context, in *DeleteFileReq, opts ...grpc.CallOption) (*DeleteFileRes, error)
}

type hellomicroClient struct {
	cc grpc.ClientConnInterface
}

func NewHellomicroClient(cc grpc.ClientConnInterface) HellomicroClient {
	return &hellomicroClient{cc}
}

func (c *hellomicroClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Hellomicro_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) Crash(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Hellomicro_Crash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) Panic(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Hellomicro_Panic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) Exit(ctx context.Context, in *ExitReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Hellomicro_Exit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) Log(ctx context.Context, in *LogReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Hellomicro_Log_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) Latency(ctx context.Context, in *LatencyReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Hellomicro_Latency_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*InfoRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfoRes)
	err := c.cc.Invoke(ctx, Hellomicro_Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) Environments(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*EnvironmentsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnvironmentsRes)
	err := c.cc.Invoke(ctx, Hellomicro_Environments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) Echo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*EchoRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EchoRes)
	err := c.cc.Invoke(ctx, Hellomicro_Echo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) Request(ctx context.Context, in *RequestReq, opts ...grpc.CallOption) (*RequestRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestRes)
	err := c.cc.Invoke(ctx, Hellomicro_Request_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) ListFiles(ctx context.Context, in *ListFilesReq, opts ...grpc.CallOption) (*ListFilesRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFilesRes)
	err := c.cc.Invoke(ctx, Hellomicro_ListFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) ReadFile(ctx context.Context, in *ReadFileReq, opts ...grpc.CallOption) (*ReadFileRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadFileRes)
	err := c.cc.Invoke(ctx, Hellomicro_ReadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) WriteFile(ctx context.Context, in *WriteFileReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Hellomicro_WriteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hellomicroClient) DeleteFile(ctx context.Context, in *DeleteFileReq, opts ...grpc.CallOption) (*DeleteFileRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteFileRes)
	err := c.cc.Invoke(ctx, Hellomicro_DeleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HellomicroServer is the server API for Hellomicro service.
// All implementations should embed UnimplementedHellomicroServer
// for forward compatibility.
type HellomicroServer interface {
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Crash(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Panic(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Exit(context.Context, *ExitReq) (*emptypb.Empty, error)
	Log(context.Context, *LogReq) (*emptypb.Empty, error)
	Latency(context.Context, *LatencyReq) (*emptypb.Empty, error)
	Info(context.Context, *emptypb.Empty) (*InfoRes, error)
	Environments(context.Context, *emptypb.Empty) (*EnvironmentsRes, error)
	Echo(context.Context, *emptypb.Empty) (*EchoRes, error)
	Request(context.Context, *RequestReq) (*RequestRes, error)
	ListFiles(context.Context, *ListFilesReq) (*ListFilesRes, error)
	ReadFile(context.Context, *ReadFileReq) (*ReadFileRes, error)
	WriteFile(context.Context, *WriteFileReq) (*emptypb.Empty, error)
	DeleteFile(context.Context, *DeleteFileReq) (*DeleteFileRes, error)
}

// UnimplementedHellomicroServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHellomicroServer struct{}

func (UnimplementedHellomicroServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedHellomicroServer) Crash(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Crash not implemented")
}
func (UnimplementedHellomicroServer) Panic(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Panic not implemented")
}
func (UnimplementedHellomicroServer) Exit(context.Context, *ExitReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exit not implemented")
}
func (UnimplementedHellomicroServer) Log(context.Context, *LogReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Log not implemented")
}
func (UnimplementedHellomicroServer) Latency(context.Context, *LatencyReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Latency not implemented")
}
func (UnimplementedHellomicroServer) Info(context.Context, *emptypb.Empty) (*InfoRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedHellomicroServer) Environments(context.Context, *emptypb.Empty) (*EnvironmentsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Environments not implemented")
}
func (UnimplementedHellomicroServer) Echo(context.Context, *emptypb.Empty) (*EchoRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}
func (UnimplementedHellomicroServer) Request(context.Context, *RequestReq) (*RequestRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Request not implemented")
}
func (UnimplementedHellomicroServer) ListFiles(context.Context, *ListFilesReq) (*ListFilesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFiles not implemented")
}
func (UnimplementedHellomicroServer) ReadFile(context.Context, *ReadFileReq) (*ReadFileRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadFile not implemented")
}
func (UnimplementedHellomicroServer) WriteFile(context.Context, *WriteFileReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteFile not implemented")
}
func (UnimplementedHellomicroServer) DeleteFile(context.Context, *DeleteFileReq) (*DeleteFileRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFile not implemented")
}
func (UnimplementedHellomicroServer) testEmbeddedByValue() {}

// UnsafeHellomicroServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HellomicroServer will
// result in compilation errors.
type UnsafeHellomicroServer interface {
	mustEmbedUnimplementedHellomicroServer()
}

func RegisterHellomicroServer(s grpc.ServiceRegistrar, srv HellomicroServer) {
	// If the following call pancis, it indicates UnimplementedHellomicroServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Hellomicro_ServiceDesc, srv)
}

func _Hellomicro_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_Crash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Crash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Crash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Crash(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_Panic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Panic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Panic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Panic(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_Exit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Exit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Exit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Exit(ctx, req.(*ExitReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_Log_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Log(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Log_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Log(ctx, req.(*LogReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_Latency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatencyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Latency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Latency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Latency(ctx, req.(*LatencyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Info(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_Environments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Environments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Environments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Environments(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Echo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Echo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_Request_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).Request(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_Request_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).Request(ctx, req.(*RequestReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFilesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).ListFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_ListFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).ListFiles(ctx, req.(*ListFilesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_ReadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).ReadFile(ctx, req.(*ReadFileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_WriteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).WriteFile(ctx, req.(*WriteFileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hellomicro_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HellomicroServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hellomicro_DeleteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HellomicroServer).DeleteFile(ctx, req.(*DeleteFileReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Hellomicro_ServiceDesc is the grpc.ServiceDesc for Hellomicro service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Hellomicro_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.hellomicro.v1.Hellomicro",
	HandlerType: (*HellomicroServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Hellomicro_Ping_Handler,
		},
		{
			MethodName: "Crash",
			Handler:    _Hellomicro_Crash_Handler,
		},
		{
			MethodName: "Panic",
			Handler:    _Hellomicro_Panic_Handler,
		},
		{
			MethodName: "Exit",
			Handler:    _Hellomicro_Exit_Handler,
		},
		{
			MethodName: "Log",
			Handler:    _Hellomicro_Log_Handler,
		},
		{
			MethodName: "Latency",
			Handler:    _Hellomicro_Latency_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Hellomicro_Info_Handler,
		},
		{
			MethodName: "Environments",
			Handler:    _Hellomicro_Environments_Handler,
		},
		{
			MethodName: "Echo",
			Handler:    _Hellomicro_Echo_Handler,
		},
		{
			MethodName: "Request",
			Handler:    _Hellomicro_Request_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _Hellomicro_ListFiles_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _Hellomicro_ReadFile_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _Hellomicro_WriteFile_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _Hellomicro_DeleteFile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/service.proto",
}
